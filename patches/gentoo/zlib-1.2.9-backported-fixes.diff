From 7de031caa4c5929a40f472a9ec50658cfcec9ea7 Mon Sep 17 00:00:00 2001
From: Kent Fredric <kentnl@gentoo.org>
Date: Mon, 20 Feb 2017 05:35:13 +1300
Subject: [rt#119762] Compress-Raw-Zlib: backport zlib 1.2.9+ fixes from
 upstream 2.073

Includes Fix for [rt#120272]

---
 cpan/Compress-Raw-Zlib/Zlib.xs                     | 163 +++++++++++++++++----
 cpan/Compress-Raw-Zlib/t/02zlib.t                  |  11 +-
 cpan/Compress-Raw-Zlib/t/compress/CompTestUtils.pm |   4 +-
 cpan/Compress-Raw-Zlib/zlib-src/inflate.c          |   7 +-
 4 files changed, 151 insertions(+), 34 deletions(-)

diff --git a/cpan/Compress-Raw-Zlib/Zlib.xs b/cpan/Compress-Raw-Zlib/Zlib.xs
index 664c26c60c..9b8b15d7de 100644
--- a/cpan/Compress-Raw-Zlib/Zlib.xs
+++ b/cpan/Compress-Raw-Zlib/Zlib.xs
@@ -74,6 +74,10 @@
 #  define AT_LEAST_ZLIB_1_2_8
 #endif
 
+#if  defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1290
+#  define AT_LEAST_ZLIB_1_2_9
+#endif
+
 #ifdef USE_PPPORT_H
 #  define NEED_sv_2pvbyte
 #  define NEED_sv_2pv_nolen
@@ -134,12 +138,13 @@ typedef struct di_stream {
     uLong    dict_adler ;
     int      last_error ;
     bool     zip_mode ;
-#define SETP_BYTE
+/* #define SETP_BYTE */
 #ifdef SETP_BYTE
+    /* SETP_BYTE only works with zlib up to 1.2.8 */
     bool     deflateParams_out_valid ;
     Bytef    deflateParams_out_byte;
 #else
-#define deflateParams_BUFFER_SIZE       0x4000
+#define deflateParams_BUFFER_SIZE       0x40000
     uLong    deflateParams_out_length;
     Bytef*   deflateParams_out_buffer;
 #endif
@@ -636,6 +641,103 @@ char * string ;
     return sv ;
 }
 
+#if 0
+int
+flushToBuffer(di_stream* s, int flush)
+{
+    dTHX;
+    int ret ;
+    z_stream * strm = &s->stream;
+
+    Bytef* output = s->deflateParams_out_buffer ;
+
+    strm->next_in = NULL;
+    strm->avail_in = 0;
+    
+    uLong total_output = 0;
+    uLong have = 0;
+
+    do 
+    {
+        if (output)
+            output = (unsigned char *)saferealloc(output, total_output + s->bufsize);
+        else
+            output = (unsigned char *)safemalloc(s->bufsize);
+
+        strm->next_out  = output + total_output;
+        strm->avail_out = s->bufsize;
+
+        ret = deflate(strm, flush);    /* no bad return value */
+        //assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
+        if(ret == Z_STREAM_ERROR)
+        {
+            safefree(output);
+            return ret;
+        }
+        have = s->bufsize - strm->avail_out;
+        total_output += have;
+
+        //fprintf(stderr, "FLUSH %s %d, return %d\n", flush_flags[flush], have, ret);
+
+    } while (strm->avail_out == 0);
+
+    s->deflateParams_out_buffer = output;
+    s->deflateParams_out_length = total_output; 
+
+    return Z_OK;
+}
+#endif
+
+#ifndef SETP_BYTE
+int
+flushParams(di_stream* s)
+{
+    dTHX;
+    int ret ;
+    z_stream * strm = &s->stream;
+
+    Bytef* output = s->deflateParams_out_buffer ;
+    uLong total_output = s->deflateParams_out_length;
+
+    uLong have = 0;
+
+    strm->next_in = NULL;
+    strm->avail_in = 0;
+    
+    do 
+    {
+        if (output)
+            output = (unsigned char *)saferealloc(output, total_output + s->bufsize);
+        else
+            output = (unsigned char *)safemalloc(s->bufsize);
+
+        strm->next_out  = output + total_output;
+        strm->avail_out = s->bufsize;
+
+        ret = deflateParams(&(s->stream), s->Level, s->Strategy);
+        /* fprintf(stderr, "deflateParams %d %s %lu\n", ret,
+            GetErrorString(ret),  s->bufsize - strm->avail_out); */
+
+        if (ret == Z_STREAM_ERROR) 
+            break;
+
+        have = s->bufsize - strm->avail_out;
+        total_output += have;
+
+
+    } while (ret == Z_BUF_ERROR) ;
+
+    if(ret == Z_STREAM_ERROR)
+        safefree(output);
+    else 
+    {
+        s->deflateParams_out_buffer = output;
+        s->deflateParams_out_length = total_output; 
+    }
+
+    return ret;
+}
+#endif /* ! SETP_BYTE */
 
 #include "constants.h"
 
@@ -995,16 +1097,19 @@ deflate (s, buf, output)
         if (s->stream.avail_out < plen) {
             /*printf("GROW from %d to %d\n", s->stream.avail_out,
                         SvLEN(output) + plen - s->stream.avail_out); */
-            Sv_Grow(output, SvLEN(output) + plen - s->stream.avail_out) ;
+             s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + plen - s->stream.avail_out) ;
+             s->stream.next_out += cur_length;
         }
         
-        Copy(s->stream.next_out, s->deflateParams_out_buffer, plen, Bytef) ;	
-        cur_length = cur_length + plen;
+        Copy(s->deflateParams_out_buffer, s->stream.next_out, plen, Bytef) ;	
+        cur_length += plen;
         SvCUR_set(output, cur_length);
 	s->stream.next_out += plen ;
 	s->stream.avail_out = SvLEN(output) - cur_length ;
 	increment = s->stream.avail_out;
 	s->deflateParams_out_length = 0;
+        Safefree(s->deflateParams_out_buffer);
+        s->deflateParams_out_buffer = NULL;
     }
 #endif
     RETVAL = Z_OK ;
@@ -1080,7 +1185,6 @@ flush(s, output, f=Z_FINISH)
   CODE:
     bufinc = s->bufsize;
   
-    s->stream.avail_in = 0; /* should be zero already anyway */
   
     /* retrieve the output buffer */
     output = deRef_l(output, "flush") ;
@@ -1088,7 +1192,7 @@ flush(s, output, f=Z_FINISH)
     if (DO_UTF8(output) && !sv_utf8_downgrade(output, 1))
          croak("Wide character in Compress::Raw::Zlib::Deflate::flush input parameter");
 #endif         
-    if(! s->flags & FLAG_APPEND) {
+    if((s->flags & FLAG_APPEND) != FLAG_APPEND) {
         SvCUR_set(output, 0);
         /* sv_setpvn(output, "", 0); */
     }
@@ -1112,16 +1216,19 @@ flush(s, output, f=Z_FINISH)
         if (s->stream.avail_out < plen) {
             /* printf("GROW from %d to %d\n", s->stream.avail_out, 
                         SvLEN(output) + plen - s->stream.avail_out); */
-            Sv_Grow(output, SvLEN(output) + plen - s->stream.avail_out) ;
+            s->stream.next_out = (Bytef*) Sv_Grow(output, SvLEN(output) + plen - s->stream.avail_out) ;
+            s->stream.next_out += cur_length;
         }
         
-        Copy(s->stream.next_out, s->deflateParams_out_buffer, plen, Bytef) ;	
-        cur_length = cur_length + plen;
+        Copy(s->deflateParams_out_buffer, s->stream.next_out, plen, Bytef) ;	
+        cur_length += plen;
         SvCUR_set(output, cur_length);
 	s->stream.next_out += plen ;
 	s->stream.avail_out = SvLEN(output) - cur_length ;
 	increment = s->stream.avail_out;
 	s->deflateParams_out_length = 0;
+        Safefree(s->deflateParams_out_buffer);
+        s->deflateParams_out_buffer = NULL;
     }
 #endif
 
@@ -1184,17 +1291,21 @@ _deflateParams(s, flags, level, strategy, bufsize)
 	int	level
 	int	strategy
     	uLong	bufsize
+	bool changed = FALSE;
     CODE:
-	/* printf("_deflateParams(Flags %d Level %d Strategy %d Bufsize %d)\n", flags, level, strategy, bufsize); 
-	printf("Before -- Level %d, Strategy %d, Bufsize %d\n", s->Level, s->Strategy, s->bufsize); */
-	if (flags & 1)
-	    s->Level = level ;
-	if (flags & 2)
-	    s->Strategy = strategy ;
-        if (flags & 4) {
+        /* printf("_deflateParams(Flags %d Level %d Strategy %d Bufsize %d)\n", flags, level, strategy, bufsize); 
+        printf("Before -- Level %d, Strategy %d, Bufsize %d\n", s->Level, s->Strategy, s->bufsize); */
+        if (flags & 1 && level != s->Level) {
+            s->Level = level ;
+            changed = TRUE;
+        }
+        if (flags & 2 && strategy != s->Strategy) {
+            s->Strategy = strategy ;
+            changed = TRUE;
+        }
+        if (flags & 4)
             s->bufsize = bufsize; 
-	}
-	/* printf("After --  Level %d, Strategy %d, Bufsize %d\n", s->Level, s->Strategy, s->bufsize);*/
+        if (changed) {
 #ifdef SETP_BYTE
         s->stream.avail_in = 0; 
         s->stream.next_out = &(s->deflateParams_out_byte) ;
@@ -1206,17 +1317,11 @@ _deflateParams(s, flags, level, strategy, bufsize)
 #else
 	/* printf("Level %d Strategy %d, Prev Len %d\n", 
                 s->Level, s->Strategy, s->deflateParams_out_length); */
-        s->stream.avail_in = 0; 
-        if (s->deflateParams_out_buffer == NULL)
-            s->deflateParams_out_buffer = safemalloc(deflateParams_BUFFER_SIZE);
-        s->stream.next_out = s->deflateParams_out_buffer ;
-        s->stream.avail_out = deflateParams_BUFFER_SIZE;
-
-	RETVAL = deflateParams(&(s->stream), s->Level, s->Strategy);
-	s->deflateParams_out_length = deflateParams_BUFFER_SIZE - s->stream.avail_out;
-	/* printf("RETVAL %d, length out %d, avail %d\n", 
-                    RETVAL, s->deflateParams_out_length, s->stream.avail_out ); */
+            RETVAL = flushParams(s);
 #endif
+        }
+        else
+            RETVAL = Z_OK;
     OUTPUT:
 	RETVAL
 
diff --git a/cpan/Compress-Raw-Zlib/t/02zlib.t b/cpan/Compress-Raw-Zlib/t/02zlib.t
index 51f2227702..329306ebbe 100644
--- a/cpan/Compress-Raw-Zlib/t/02zlib.t
+++ b/cpan/Compress-Raw-Zlib/t/02zlib.t
@@ -31,7 +31,7 @@ BEGIN
         $count = 232 ;
     }
     elsif ($] >= 5.006) {
-        $count = 317 ;
+        $count = 320 ;
     }
     else {
         $count = 275 ;
@@ -563,6 +563,13 @@ SKIP:
     is $x->get_Level(),    Z_BEST_SPEED;
     is $x->get_Strategy(), Z_HUFFMAN_ONLY;
      
+    # change both Level & Strategy again without any calls to deflate 
+    $status = $x->deflateParams(-Level => Z_DEFAULT_COMPRESSION, -Strategy => Z_DEFAULT_STRATEGY, -Bufsize => 1234) ;
+    cmp_ok $status, '==', Z_OK ;
+    
+    is $x->get_Level(),    Z_DEFAULT_COMPRESSION;
+    is $x->get_Strategy(), Z_DEFAULT_STRATEGY;
+     
     $status = $x->deflate($goodbye, $Answer) ;
     cmp_ok $status, '==', Z_OK ;
     $input .= $goodbye;
@@ -572,7 +579,7 @@ SKIP:
     cmp_ok $status, '==', Z_OK ;
     
     is $x->get_Level(),    Z_NO_COMPRESSION;
-    is $x->get_Strategy(), Z_HUFFMAN_ONLY;
+    is $x->get_Strategy(), Z_DEFAULT_STRATEGY;
      
     $status = $x->deflate($goodbye, $Answer) ;
     cmp_ok $status, '==', Z_OK ;
diff --git a/cpan/Compress-Raw-Zlib/t/compress/CompTestUtils.pm b/cpan/Compress-Raw-Zlib/t/compress/CompTestUtils.pm
index 9815eb2caa..1543ef92ca 100644
--- a/cpan/Compress-Raw-Zlib/t/compress/CompTestUtils.pm
+++ b/cpan/Compress-Raw-Zlib/t/compress/CompTestUtils.pm
@@ -70,8 +70,8 @@ BEGIN {
 
     our ($index);
     $index = '00000';
-    our ($useTempFile) = defined &File::Temp::tempdir;
-    our ($useTempDir) = defined &File::Temp::newdir;
+    our ($useTempFile);
+    our ($useTempDir);
     
     sub new
     {
diff --git a/cpan/Compress-Raw-Zlib/zlib-src/inflate.c b/cpan/Compress-Raw-Zlib/zlib-src/inflate.c
index c938f49ba7..6047cd884f 100644
--- a/cpan/Compress-Raw-Zlib/zlib-src/inflate.c
+++ b/cpan/Compress-Raw-Zlib/zlib-src/inflate.c
@@ -1494,6 +1494,7 @@ int ZEXPORT inflateUndermine(
     state->sane = !subvert;
     return Z_OK;
 #else
+    (void)subvert;
     state->sane = 1;
     return Z_DATA_ERROR;
 #endif
@@ -1504,7 +1505,11 @@ long ZEXPORT inflateMark(
 {
     struct inflate_state FAR *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
+    /* Change to return statement below is taken from 
+           https://github.com/madler/zlib/commit/2edb94a3025d288dc251bc6cbb2c02e60fbd7438 
+     */
+    if (strm == Z_NULL || strm->state == Z_NULL)
+        return -(1L << 16);
     state = (struct inflate_state FAR *)strm->state;
     return ((long)(state->back) << 16) +
         (state->mode == COPY ? state->length :
-- 
2.11.1

